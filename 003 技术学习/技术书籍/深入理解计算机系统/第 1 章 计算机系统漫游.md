计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化，但是内在的概念却没有改变。所有计算机系统都有着相似的硬件和软件，而它们又执行着相似的功能。

我们将跟踪 `hello` 程序的生命周期来开始对系统的学习——从它被程序员创建开始，到在系统上运行，输出简单的信息，最后中止。

```c file:hello.c
#include <stdio.h>

int main() {
  printf("Hello world!\n");
  return 0;
}
```

---

# 信息就是位 + 上下文

`hello` 程序的生命周期是从源文件开始的，本质上是比特序列，像 `hello.c` 这样只由字符构成的文件称为文本文件，所有其他文件都称为二进制文件。

`hello.c` 的表示方法说明了一个基本思想：系统中所有的信息，包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。

---

# 程序被其他程序翻译成不同的格式

为了在系统上运行 `hello.c` 程序，每条 C 语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序（可执行目标文件）的格式打包，并以二进制文件的形式存放起来。

Linux 系统上，从源文件到目标文件的转化是由编译期驱动程序（例如 GCC 或者 Clang）完成的，这个翻译过程可以分为四个阶段，如图所示。执行这四个阶段的程序（预处理器，编译期，汇编器和链接器）一起构成了编译系统 (compilation system）。

![[003 技术学习/技术书籍/深入理解计算机系统/Img/Chap01/CompilationSystem.svg]]

- 预处理阶段。预处理器（`cpp`）根据以字符 `#` 开头的命令，修改原始的 C 程序。比如 `hello.c` 中第 1 行的 `#include <stdio.h>` 命令告诉预处理器读取系统头文件 `stdio.h` 的内容，并把它直接插入程序文本中。结果就得到了另一个 C 程序，通常是以 `.i` 作为文件扩展名。
- 编译阶段。编译器（`cc1`）将文本文件 `hello.i` 翻译成文本文件 `hello.s`，它包含一个汇编语言程序。该程序包含函数 `main` 的定义，如下所示：

```nasm file:hello.s
main:
    subq $8, %rsp
    movl $.LC0, %edi
    call puts
    movl $0, %eax
    addq $8, %rsp
```

- 汇编阶段。接下来，汇编器（`as`）将 `hello.s` 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件 `hello.o` 中。
- 链接阶段。`hello` 程序调用了 `printf` 函数，它是 C 编译器提供的标准 C 库中的一个函数。`printf` 函数存在于一个名为 `printf.o` 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 `hello.o` 程序中。链接器（`ld`）就负责处理这种合并。结果就得到 `hello` 文件，它是一个可执行目标文件，可以被加载到内存中，由系统执行。

---

# 了解编译系统如何工作是大有益处的

- 优化程序性能。
- 理解链接时出现的错误。
- 避免安全漏洞。

---

# 处理器读并解释储存在内存中的指令

![[003 技术学习/技术书籍/深入理解计算机系统/Img/Chap01/HardwareOrganization.svg]]

## 系统的硬件组成

### 总线

贯穿整个系统的是一组电子管道，称作总线（buses），它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。

### I/O 设备

输入/输出（I/O）设备是系统与外部世界的联系通道。每个 I/O 设备都通过一个控制器或适配器与 I/O 总线相连。

### 主存

主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从 0 开始的。

### 处理器

中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。

从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。

### 运行 hello 程序

初始时，shell 程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串 `./hello` 后，shell 程序将字符逐一读入寄存器，再把它存放到内存中。

当我们在键盘上敲回车键时，shell 程序就知道我们已经结束了命令的输入。然后 shell 执行一系列指令来加载可执行的 hello 文件，这些指令将 hello 目标文件中的代码和数据通过 DMA 的方式直接从磁盘复制到主存。数据包括最终会被输出的字符串 `"hello, world\n"`。

一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello 程序的 main 中的机器语言指令。这些指令将 `"hello, world\n"` 字符串中的字节从主存复制到寄存器中，再从寄存器中复制到显示设备，最终显示在屏幕上。

---

# 高速缓存至关重要

上面的这个例子说明一个系统会花费大量的时间，来将信息从一个地方移动到另一个地方。`hello` 程序原本被存储在磁盘上，当该程序被加载时，会先被搬运到主存上，它的指令会再从主存搬运到处理器上。

由于物理限制，大容量的存储设备会慢于小容量的存储设备，快速设备会贵于慢速设备。通常，处理器上的寄存器要比主存快得多，但其容量很小，造价也更高。

针对处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为 cache，作为暂时的集结区域，存放处理器近期可能会需要的信息。比较新的、处理能力更强大的系统有三级 cache：L1、L2 和 L3。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常性访问的数据，大部分的内存操作都能在快速的高速缓存中完成。

---

# 存储设备形成层次结构

在每个计算机系统中的存储设备都被组织成了一个存储器层次结构，如图所示。在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。

![[003 技术学习/技术书籍/深入理解计算机系统/Img/Chap01/MemoryHierarchy.svg]]

存储器层次结构的主要思想是上一层的存储器作为第一层存储器的高速缓存。

---

# 操作系统管理硬件

当 shell 加载和运行 hello 程序时，以及 hello 程序输出自己的消息时，shell 和 hello 程序都没有直接访问键盘、显示器、磁盘或者主存，而是依靠操作系统提供的服务。可以把操作系统看成是应用程序和硬件之间插入的一层软件，如图所示。所有应用程序对硬件的操作尝试都必须通过操作系统。

![[003 技术学习/技术书籍/深入理解计算机系统/Img/Chap01/LayeredViewOfComputer.svg]]

操作系统有两个基本功能：(1) 防止硬件被失控的应用程序滥用；(2) 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。如图所示，文件是对 I/O 设备的抽象表示，虚拟内存是对主存和磁盘 I/O 设备的抽象表示，进程是对处理器、主存和 I/O 设备的抽象表示。

![[003 技术学习/技术书籍/深入理解计算机系统/Img/Chap01/AbstractionsOfOS.svg]]

## 进程

当 `hello` 程序运行在一个现代系统上时，操作系统会提供一种该程序正在独占式运行的假象。

进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以并发运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。操作系统实现这种交错执行的机制称为上下文切换。

操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如 PC 和寄存器文件的当前值，以及主存的内容。在任一时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。

从一个进程到另一个进程的转换是由操作系统内核（kernel）管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用（system call）指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。

## 线程

在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。线程相比于进程的优点是，它可以更容易地共享数据，同时也执行得更高效。

## 虚拟内存

虚拟内存是一个抽象概念，它为每个进程提供了一个假象：每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。下图为 Linux 进程的虚拟地址空间。在 Linux 中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都一样；地址空间的底部区域存放用户进程定义的代码和数据。

![[003 技术学习/技术书籍/深入理解计算机系统/Img/Chap01/VirtualAddressSpace.svg]]

每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。

- **程序代码和数据**。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和 C 全局变量相对应的数据位置。
- **堆**。代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像 `malloc` 和 `free` 这样的 C 标准库函数时，堆可以在运行时动态地扩展和收缩。
- **共享库**。大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。
- **栈**。位于用户虚拟地址空间顶部的是**用户栈**，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。
- **内核虚拟内存**。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。

## 文件

文件就是字节序列，仅此而已。每个 I/O 设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。文件这个概念向应用程序提供了一个统一的视图，来看待系统中各式各样的 I/O 设备。

---

# 系统之间利用网络通信

现代系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个 I/O 设备。当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器；相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。

---

# 重要主题

## Amdahl 定律

该定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。

> [!theorem] Amdahl's Law
> 若某系统执行某应用程序需要时间为 $T_{\text{old}}$ 。假设系统某部分所需执行时间与该时间的比例为 $\alpha$ ，而该部分性能提升比例为 $k$ 。即该部分初始所需时间为 $\alpha T_{\text{old}}$ ，现在所需时间为 $(\alpha T_{\text{old}}) / k$ 。因此，总的执行时间应为
> 
> $$
> T_{\text{new}} = (1 - \alpha) T_{\text{old}} + (\alpha T_{\text{old}}) / k = T_{\text{old}}[(1 - \alpha) + \alpha / k]
> $$
> 
> 由此，可以计算加速比 $S = T_{\text{old}} / T_{\text{new}}$ 为
> 
> $$
> S = \frac{1}{(1 - \alpha) + \alpha / k}
> \tag{1-1}
> $$
> 
> ^1-1

Amdahl 定律揭示了，要想显著加速整个系统，必须提升全系统中相当大的部分的速度。

根据式 [[#^1-1]] ，我们可以考虑将 $k$ 设置为 $\infty$，这意味着我们将系统中某一部分的时间加速到了 $0$。于是我们可以得到：

$$
S_\infty = \frac{1}{(1 - \alpha)}
\tag{1-2}
$$

^1-2

式 [[#^1-2]] 说明，即使我们将单一部分的优化做到极致，也不会继续产生加速效果；要想继续提升，需要优化系统的大部分组件。

## 并发与并行

**并发**（concurrency）是一个通用的概念，指一个同时具有多个活动的系统；而**并行**（parallelism）指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。在此，我们按照系统层次结构中由高到低的顺序重点强调三个层次。

### 线程级并发

构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。在传统的单处理系统中，这种并发是模拟出来的；现代处理器使用超线程（hyperthreading）技术来支持线程级并发。

多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要；其次，它可以使多线程应用程序运行得更快。

### 指令级并行

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性被称为指令级并行。如果处理器可以达到比一个周期一条指令更快的执行效率，就称之为超标量（superscalar）处理器。

### 单指令、多数据并行

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即 SIMD 并行。

## 计算机系统中抽象的重要性

抽象的使用是计算机科学中最为重要的概念之一。

在处理器里，指令集架构提供了对实际处理器硬件的抽象。使用这个抽象，机器代码程序表现得就好像运行在一个一次只执行一条指令的处理器上。在学习操作系统时，我们介绍了三个抽象：文件是对 I/O 设备的抽象，虚拟内存是对程序存储器的抽象，而进程是对一个正在运行的程序的抽象。我们再增加一个新的抽象：虚拟机，它提供对整个计算机的抽象，包括操作系统、处理器和程序。

![[003 技术学习/技术书籍/深入理解计算机系统/Img/Chap01/AbstractionsOfSystem.svg]]

---

# 小结

计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是纯文本，然后被编译器和链接器翻译成二进制可执行文件。

处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O 设备和 CPU 寄存器之间复制数据，所以将系统中的存储设备划分成层次结构——CPU 寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM 主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化 C 程序的性能。

操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象∶1）文件是对 I/O 设备的抽象；2）虚拟内存是对主存和磁盘的抽象；3）进程是处理器、主存和 I/O 设备的抽象。

最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种 I/O 设备。
