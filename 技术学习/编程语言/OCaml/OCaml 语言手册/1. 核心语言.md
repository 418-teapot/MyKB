
---

# 基本

对于 OCaml 的概述，我们使用交互式系统，该系统通过命令行运行 `ocaml` 来启动。本教程以交互式系统会话的记录形式来呈现：以 `#` 开头的行代表用户输入；系统响应在下面，不以 `#` 开头。

在交互式系统下，用户输入以 `#` 开头 `;;` 结尾的 OCaml 短语，系统即时进行编译、执行、并打印结果。短语要么是简单的表达式，要么是 `let` 定义的标识符（值或函数）。

```ocaml
# 1 + 2 * 3;;
- : int = 7
```

```ocaml
# let pi = 4.0 .* atan 1.0;;
val pi : float = 3.14159265358979312
```

```ocaml
# let square x = x *. x;;
val square : float -> float = <fun>
```

```ocaml
# square (sin pi) +. square (cos pi);;
- : float = 1.
```

OCaml 系统会计算每个短语的值和类型。函数参数不需要显式地声明类型，系统会根据它们在函数中的用法推断出它们的类型。需要注意的是，整数和浮点数是不同的类型，具有不同的运算符：整数运算使用 `+` 和 `*`，浮点数运算使用 `+.` 和 `*.` 。

```ocaml
# 1.0 * 2;;
Error: This expression has type float but an expression was expected of type int
```

递归函数的定义是通过 `let rec` 绑定的：

```ocaml
# let rec fib b =
    if n < 2 then n else fib (n - 1) + fib (n - 2);;
val fib : int -> int = <fun>
```

```ocaml
# fib 10;;
- : int = 55
```

---

# 数据类型

除了整型和浮点型之外，OCaml 还提供了常用的基本数据类型：

- bool 型

```ocaml
# (1 < 2) = false;;
- : bool = false
```

```ocaml
# let one = if true then 1 else 2;;
val one : int = 1
```

- char 型

```ocaml
# 'a';;
- : char = 'a'
```

```ocaml
# int_of_char '\n';;
- : int = 10
```

- 不可变字符串

```ocaml
# "Hello" ^ " " ^ "world";;
- : string = "Hello world"
```

```ocaml
# {|This is a quoted string, here, neither \ nor " are special characters|};;
- : string =
"This is a quoted string, here, neither \\ nor \" are special characters"
```

```ocaml
# {|"\\"|} = "\"\\\\\""
- : bool = true
```

```ocaml
# {delimiter|the end of this|}quoted string is here|delimter}
  = "the end of this|}quoted string is here";;
- : bool = true
```

预定义数据结构包括元组、数组和列表。还有一些通用机制可以定义自己的数据结构，例如记录和变体。现在，我们专注于列表。列表要么通过分号分隔元素的括号列表给出，要么通过使用 `::` 运算符在空列表 `[]` 前添加元素构建。

```ocaml
# let l = ["is"; "a"; "tale"; "told"; "etc."];;
val l : string list = ["is"; "a"; "tale"; "told"; "etc."]
```

```ocaml
# "Life" :: l;
- : string list = ["Life"; "is"; "a"; "tale"; "told"; "etc."]
```

与其他数据结构一样，列表不需要显式地从内存中分配和释放：所有内存管理在 OCaml 中都是完全自动的。同样，没有显式的指针处理：OCaml 编译器在必要时会静默地引入指针。

与大多数数据结构一样，列表的检查和析构是通过模式匹配执行的。列表模式与列表表达式具有完全相同的形式，其中标识符表示列表中未指定的部分。作为示例，下面是列表上的插入排序：

```ocaml
# let rec sort lst =
    match lst with
      [] -> []
    | head :: tail -> insert head (sort tail)
  and insert elt lst =
    match lst with
      [] -> [elt]
    | head :: tail -> if elt <= head then elt :: lst
                                     else head :: insert elt tail
  ;;
val sort : 'a list -> 'a list = <fun>
val insert : 'a -> 'a list -> 'a list = <fun>
```

```ocaml
# sort l;;
- : string list = ["a"; "etc."; "is"; "tale"; "told"]
```

OCaml 推断的 `sort` 的类型：`'a list -> 'a list`，意味着 `sort` 可以应用于任何类型的列表，并返回相同类型的列表。类型 `'a` 是一个类型变量，代表任何给定的类型。`sort` 可以应用于任何类型的列表的原因是，OCaml 中的比较操作（`=`, `<=` 等）是多态的：它们可以在任意两个相同类型的值之间操作。这使得 `sort` 对于所有列表类型都具有多态性。

```ocaml
# sort [6; 2; 5; 3];;
- : int list = [2; 3; 5; 6]
```

```ocaml
# sort [3.14; 2.718];;
- : float list = [2.718; 3.14]
```

上面的 `sort` 函数不会修改其输入的列表：它会构建并返回升序的、与输入列表具有相同元素的新列表。实际上，OCaml 中无法在构建列表中后原位修改，因此我们可以说，列表是不可变数据结构。大多数 OCaml 数据结构都是不可变的，但是少数（尤其是数组）是可变的，这意味着它们随时可能被原位修改。

具有多个参数的函数类型在 OCaml 中表示为： `arg1_type -> arg2_type -> ... -> return_type`。例如，为 `insert` 推断的类型 `'a -> 'a list -> 'a list` 意味着 `insert` 接收两个参数：任意类型 `'a` 的元素和包含相同类型 `'a` 的元素列表，并返回相同类型的列表。

---

# 函数作为值

OCaml 是一门函数式语言：支持完整数学意义上的函数，并且可以像任何其他数据一样可以自由传递。例如，下面是一个 `deriv` 函数，它接收任何浮点函数作为参数并返回其导数函数的近似值：

```ocaml
# let deriv f dx = fun x -> (f (x +. dx) -. f x) /. dx;
val deriv : (float -> float) -> float -> float -> float = <fun>
```

```ocaml
# let sin' = deriv sin 1e-6;;
val sin' : float -> float = <fun>
```

```ocaml
# sin' pi;;
- : float = -1.00000000013961143
```

甚至函数组合也是可以定义的：

```ocaml
# let compose f g = fun x -> f (g x);;
val compose : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
```

```ocaml
# let cos2 = compose square cos;;
val cos2 : float -> float = <fun>
```

以其他函数作为参数的函数称为“泛函”或“高阶函数”。泛函在为数据结构提供迭代器会类似的通用操作特别有用。例如，OCaml 标准库提供了一个 `List.map` 函数，它将给定的函数应用于列表中的每个元素，并返回结果列表：

```ocaml
# List.map (fun n -> n * 2 + 1) [0; 1; 2; 3; 4];;
- : int list = [1; 3; 5; 7; 9]
```

该泛函以及许多其他列表和数组泛函因为很有用，所有被预定义出来，但它没有什么魔法：它可以轻松地如下定义出来。

```ocaml
# let rec map f l =
    match l with
      [] -> []
    | head :: tail -> f head :: map f tail;;
val map : ('a -> 'b) -> 'a list -> 'b list = <fun>
```
