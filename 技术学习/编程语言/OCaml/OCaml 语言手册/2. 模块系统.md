
---

# 结构体

模块的主要动机是把相关的定义（例如数据类型的定义和该类型的相关操作）打包在一起，并为这些定义强制执行统一的命名方案。这可以避免名称用完或者混淆。这样的包称为结构体，由 `struct...end` 来进行构造，其中包含任意序列的定义。该结构通常通过 `module` 绑定来命名。例如，下面是一个将一种 FIFO 队列及其操作封装在一起的结构体：

```ocaml
# module Fifo =
    struct
      type 'a queue = { front: 'a list; rear: 'a list }
      let make front rear =
        match front with
        | [] -> { front = List.rev rear; rear = [] }
        | _ -> { front; rear }
      let empty = { front = []; rear = [] }
      let is_empty = function { front = []; _ } -> true | _ -> false
      let add x q = make q.front (x :: q.rear)
      exception Empty
      let top = function
        | { front = []; _ } -> raise Empty
        | { front = x :: _; _ } -> x
      let pop = function
        | { front = []; _ } -> raise Empty
        | { front = _ :: f; rear = r } -> make f r
    end;;
module Fifo :
  sig
    type 'a queue = { front : 'a list; read : 'a list }
    val make : 'a list -> 'a list -> 'a queue
    val empty : 'a queue
    val is_empty : 'a list -> bool
    val add : 'a -> 'a queue -> 'a queue
    exception Empty
    val top -> 'a queue -> 'a
    val pop -> 'a queue -> 'a queue
  end
```

在结构体之外，可以使用“点符号”来引用其组件，即由结构体名称限定的标识符。例如，`Fifo.add` 是结构体 `Fifo` 中定义的 `add` 函数，`Fifo.queue` 是 `Fifo` 中定义的类型 `queue`。

```ocaml
# Fifo.add "hello" Fifo.empty;;
- : string Fifo.queue = {Fifo.front = ["hello"]; rear = []}
```

另一种方法是使用 `open`，它会将模块内定义的所有标识符带入到当前结构体的作用范围。

```ocaml
# open Fifo;;
```

```ocaml
# add "hello" empty;;
- : string Fifo.queue = {front = ["hello"]; rear = []}
```

打开模块可以更轻松地访问其组件，但代价是更难以识别标识符是在哪个模块中定义的。特别的是，打开的模块会遮蔽当前作用域中存在的标识符，从而可能会导致错误：

```ocaml
# let empty = []
  open Fifo;;
val empty : 'a list = []
```

```ocaml
# let x = 1 :: empty;;
Error: This expression has type 'a Fifo.queue
       but an expression was expected of type int list
```

该难题的一个部分解决方法是在局部将模块打开，使该模块的组件仅在相关表达式中可用。这还可以使代码更易于阅读（因为 `open` 语句更接近其使用位置），并且更易于重构（因为代码片段更加独立）。有两种结构可用于此目的：

```ocaml
# let open Fifo in
  add "hello" empty;;
- : string Fifo.queue = {front = ["hello"]; rear = []}
```

和

```ocaml
# Fifo.(add "hello" empty);;
- : string Fifo.queue = {front = ["hello"]; rear = []}
```

在第二种形式中，当 local open 的主体本身由圆括号、大括号或方括号定界时，可以省略 open 的圆括号。例如，

```ocaml
# Fifo.[empty] = Fifo.([empty]);;
- : bool = true
```

```ocaml
# Fifo.[|empty|] = Fifo.([|empty|]);;
- : bool = true
```

```ocaml
# Fifo.{contents = empty} = Fifo.({contents = empty})
- : bool = true
```

第二种形式也适用于模式匹配：

```ocaml
# let at_most_one_element x = match x with
  | Fifo.{front = ([] | [_]); rear = []} -> true
  | _ -> false;;
val at_most_one_element : 'a Fifo.queue -> bool = <fun>
```

还可以使用 `include` 语句将一个模块的组件复制到另一个模块中。这对于扩展现有模块十分有用。作为说明，我们可以添加一个在队列为空时返回 optional 值而不是异常的函数。

```ocaml
# module FifoOpt =
  struct
    include Fifo
    let top_opt q = if is_empty q then None else Some(top q)
    let pop_opt q = if is_empty q then None else Some(pop q)
  end;;
module FifoOpt :
  sig
    type 'a queue = 'a Fifo.queue = { front : 'a list; rear : 'a list; }
    val make : 'a list -> 'a list -> 'a queue
    val empty : 'a queue
    val is_empty : 'a queue -> bool
    val add : 'a -> 'a queue -> 'a queue
    exception Empty
    val top : 'a queue -> 'a
    val pop : 'a queue -> 'a queue
    val top_opt : 'a queue -> 'a option
    val pop_opt : 'a queue -> 'a queue option
  end
```
