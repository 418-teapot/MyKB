
---

需要注意的是，OCaml 中对象、类、类型之间的关系与 Java 和 C++ 等面向对象语言中的关系不同。与这些语言相比，Ocaml 中使用面向对象功能的频率要低得多。OCaml 通常有更合适的替代方案，例如模块和函子。事实上，许多 OCaml 程序根本不使用对象。

---

# 类与对象

下面的类 `point` 定义了一个实例变量 `x` 和两个方法 `get_x` 和 `move`。这个实例变量的初始值为 `0`。变量 `x` 被声明为可变的，因此 `move` 方法可以改变它的值。

```ocaml
# class point =
    object
      val mutable x = 0
      method get_x = x
      method move d = x <- x + d
    end;;
```

```
class point :
  object val mutable x : int method get_x : int method move : int -> unit end
```

我们现在创建一个点 `p`，即 `point` 类的实例。

```ocaml
# let p = new point;;
```

```
val p : point = <obj>
```

需要注意的是 `p` 的类型是 `point`。这是由上面的类定义自动定义的缩写，它代表对象类型 `<get_x : int; move : int -> unit>`（列出类 `point` 的方法及其类型）。

我们可以调用 `p` 中的一些方法：

```ocaml
# p#get_x;;
```

```
- : int = 0
```

```ocaml
# p#move 3;;
```

```
- : unit = ()
```

```ocaml
# p#get_x;;
```

```
- : int = 3
```

类体的执行仅在对象创建时进行。因此，在下面的示例中，实例变量 `x` 对于两个不同的对象被初始化为不同的值：

```ocaml
# let x0 = ref 0;;
```

```
val x0 : int ref = {contents = 0}
```

```ocaml
# class point =
    object
      val mutable x = incr x0; !x0
      method get_x = x
      method move d = x <- x + d
    end;;
```

```
class point :
  object val mutable x : int method get_x : int method move : int -> unit end
```

```ocaml
# new point#get_x;;
```

```
- : int = 1
```

```ocaml
new point#get_x;;
- : int = 2
```

类 `point` 也可以通过 `x` 的初始值进行抽象。

```ocaml
# class point = fun x_init ->
    object
      val mutable x = x_init
      method get_x = x
      method move d = x <- x + d
    end;;
```

```
class point :
  int ->
  object val mutable x : int method get_x : int method move : int -> unit end
```

与函数定义一样，上面的定义可以缩写为：

```ocaml
# class point x_init =
    object
      val mutable x = x_init
      method get_x = x
      method move d = x <- x + d
    end;;
```

```
class point :
  int ->
  object val mutable x : int method get_x : int method move : int -> unit end
```

类 `point` 的实例现在是一个需要初始化参数来创建对象的函数：

```ocaml
# new point;;
```

```
- : int -> point = <fun>
```

```ocaml
# let p = new point 7;;
```

```
val p : point = <obj>
```

参数 `x_init` 在定义的整个类体中都是可见的，包括方法。例如，下面的 `get_offset` 方法会返回对象相对于其初始位置的偏移。

```ocaml
# class point x_init =
    object
      val mutable x = x_init
      method get_x = x
      method get_offset = x - x_init
      method move d = x <- x + d
    end;;
```

```
class point :
  int ->
  object
    val mutable x : int
    method get_x : int
    method get_offset : int
    method move : int -> unit
  end
```

在定义类体之前可以对表达式进行求值和绑定。这对于强制不变量来说十分有用。例如，点可以自动调整到网格上最近的点，如下所示：

```ocaml
# class adjusted_point x_init =
    let origin = (x_init / 10) * 10 in
      object
        val mutable x = origin
        method get_x = x
        method get_offset = x - origin
        method move d = x <- x + d
      end;;
```

```
class adjusted_point :
  int ->
  object
    val mutable x : int
    method get_x : int
    method get_offset : int
    method move : int -> unit
  end
```

（如果 `x_init` 坐标不在网格上，也可以触发异常。）事实上，通过使用 `origin` 的值来初始化 `point` 类的定义，也可以得到相同的效果。

```ocaml
# class adjusted_point x_init = point ((x_init / 10) * 10);;
```

```
class adjusted_point : int -> point
```

另一种方法是在特殊分配函数中定义：

```ocaml
# let new_adjusted_point x_init = new point ((x_init / 10) * 10);;
```

```
val new_adjusted_point : int -> point = <fun>
```

然而，前一种模式通常会更合适，因为用于调整的代码是类定义的一部分，并且将被继承。

这种能力提供了类构造器，类似于其他语言中的实现方式。可以通过定义多个构造器来创建同一个类的对象，但可以具有不同的初始化模式；另一种方法是使用初始化器，如下面章节所述。
