
---

# 值与类型

Lua 是一门动态类型语言。这意味着变量没有类型，只有值才有类型。在该语言中也没有类型定义。所有的值都有它们自己的类型。

所有的值在 Lua 中都是第一公民。这意味着所有的值都可以存储在变量中，作为参数传递给函数，或者作为结果返回。

Lua 中由 8 种基本类型：`nil`, `boolean`, `number`, `string`, `function`, `userdata`, `thread`, `table`。`nil` 类型只有一个值即 `nil`，其与任何其他值均不同，它通常代表缺少有用的值。`boolean` 类型有两个值：`false` 和 `true`。`nil` 和 `false` 都能使条件为假，因此也被统称为 false 值。任何其他值都能使条件为真。`false` 经常被用作 `nil` 的代替品，其主要区别在与 `false` 的行为类似于 `table` 中的常规值，而 `table` 中的 `nil` 表示不存在的键。

`number` 类型表示整数和浮点数，使用两种子类型：`integer` 和 `float`。标准 Lua 使用 64 位整型和双精度浮点型，但也可以自行编译使用 32 位整型和单精度浮点型的 Lua。

除非有另外说明，否则根据补码运算的通常规则，操作整型值的任何溢出都会发生回绕行为。

Lua 对于何时使用哪个子类型有明确的规则，但也会根据需要在它们之间自动转换。因此，程序员可以选择忽略整型和浮点型之间的差异，或者完全控制每个数字的表示。

`string` 类型表示不可变的字节序列，字符串可以包含任何 8-bit 值，包括 `'\0'` 等。Lua 也是与编码无关的，它不到字符串的内容做任何假设。Lua 中任何字符串的长度都必须满足 Lua 中整型的限制。

Lua 中可以调用和操作用 Lua 和 C 编写的函数，两者都表示为 `function` 类型。

`userdata` 类型允许将任意 C 数据存储在 Lua 变量中。一个 `userdata` 值表示一块原始内存。有两种 `userdata`：*full userdata*，它是一个由 Lua 管理的内存块的对象；*light userdata*，它只是一个 C 指针。`userdata` 在 Lua 中除了赋值和同一性检验之外，没有其他预定义的操作。通过使用元表，程序员可以定义 *full userdata* 值的操作。`userdata` 值无法在 Lua 中创建或者修改，只能通过 C API 来进行。这保证了主机程序和 C 库中所拥有的数据的完整性。

`thread` 类型代表独立的执行线程，它用于实现协程。Lua 线程与操作系统线程无关。Lua 支持所有系统上的协程，甚至是那些本身不支持线程的系统。

`table` 类型实现了关联数组，不仅可以将数字作为索引，还可以将除了 `nil` 和 `NAN` 之外的任何 Lua 值作为索引。`table` 可以是异构的，可以包含除了 `nil` 之外所有类型的值。与 `nil` 值关联的任何键都不被视为 `table` 的一部分。相反，任何不属于 `table` 的键都具有关联值 `nil`。

`table` 是 Lua 中唯一的数据结构机制，它可以用来表示普通的数组、列表、符号表、集合、记录、图、树等。为了表示记录，Lua 使用字段名作为索引。Lua 提供 `a.name` 作为 `a["name"]` 的语法糖来支持这种表示。

与索引一样，`table` 的字段值也可以是任何类型。特别的是，因为函数是一等值，所以 `table` 字段可以包含函数，因此 `table` 可以携带方法。

`table` 的索引遵循语言中原始相等的定义。当且仅当 `i` 和 `j` 原始相等（除了元方法外，均相等）时，表达式 `a[i]` 和 `a[j]` 表示相同的表元素。特别是，具有整数值的浮点数等于它们各自的整数（例如，`1.0 == 1`）。为了避免歧义，任何用作浮点数键，如果与一个整数值相等，都会转为该整数值。例如，如果写入了 `a[2.0] == true`，则插入表中的实际的键会是整数值 `2`。

`table`, `function`, `thread`, `(full) userdata` 值都是对象：变量实际上并不包含这些值，仅包含对它们的引用。赋值、参数传递、函数返回等操作，只是在操作对这些值的引用，而不会产生任何的拷贝。

库函数 `type` 会返回一个描述给定值的类型的字符串。
